# Hiển thị ảnh
Mấy cái hình tĩnh phức tạp hay hiệu ứng thay vì code hãy tạo bằng design chuẩn kích thước r đưa vào sẽ ok hơn. Ít khi ảnh gif thôi.

-> Khi user input ảnh, ta kb được, có thể kích thước cực to
- Chủ động cho họ cut ảnh kiểu avatar
- Chủ động kéo dãn or cut và lấy center theo tỉ lệ khung fix sẵn sao cho cả khung luôn có ảnh

Set kích thước ảnh thì nên set cho thẻ div bao ngoài
<Box style={{width: "300px", height: "300px"}}>
  <img width="100%" />
</Box>
=> K sợ bị méo ảnh và luôn là 300px dọc và ngang dù ta có chỉnh bất cứ phần tử bao ngoài hay co màn hình như nào



# Dùng font chữ
Cài font: yarn add @fontsource/roboto; import "@fontsource/roboto"; => dùng với font-family: "Roboto"

Thêm google font API CDN trong public/index.html, phải link cả các font-size và font-weight mới set css được. 
VD: <link href="https://fonts.googleapis.com/css2?family=Source+Sans+Pro:wght@200;300;400;600&display=swap" rel="stylesheet"> => Set được font-weight: 200, 300, 400, 600. Các size khác sẽ k có tác dụng

Import font file trực tiép vào rồi định nghĩa trong file css với @font-face



# Synthetic Event
URL: https://reactjs.org/docs/events.html
React bắt event user tạo sẽ wrap native browser events vào 1 cái wrapper có interface, bên trong cung các method như preventDefault() để sử dụng 
NN dùng wrapper chung bởi vì cùng 1 event với browser khác nhau sẽ có tên khác nhau. Wrapper sẽ gom thành 1 thứ duy nhất và trigger event thực của real dom tùy theo browser. Tức các sự kiện ta trigger như onClick, onBlur, onChange là ReactJS custom event (Synthetic Event) chứ kp real dom event . Cái wrapper kia gọi là SyntheticEvent object.

Nhờ đó dễ dàng tạo ra cross browser app. Nó giúp tăng performance vì Synthetic Event được pooled và resused accross multiple native events. Khi 1 event xảy ra, React sẽ lấy 1 đối tượng sự kiện từ pool, set các thuộc tính dựa trên sự kiện gốc, xử lý xong sẽ đưa lại về pool để tái sử dụng cho các sự kiện tiếp theo.
Event pool chứa system events và events tự định nghĩa. Mỗi action tương tác sẽ thêm vào pool này. Khi đó nó lấy từ pool ra dần dần thực hiện xử lý các thứ. 

-> event.stopPropagation() sẽ cản trở event tiếp tục bubble up và thực hiện tiếp các hàm khác
event.persist() => cản event được pool bằng cách set null luôn => Bỏ vì phiên bản mới, SyntheticEvent k còn được pooled nữa



# Import export trong React
ES6 (FE): có export theo tên và default export
CommonJS (NodeJS): exports là viết tắt của module.exports

-> Hàm require chỉ chạy trên server. Dùng require sẽ thêm toàn bộ code dự án vào theo thứ tự file js. Còn import của front end là thêm 1 module bất đồng bộ.
Trong React, ngoài folder src dùng CommonJS, files trong src dùng ES6. Tuỳ biến package Browsify có thể cấu hình FE dùng CommonJS, package Babel giúp NodeJS dùng ES6 được.
Trong HTML CSS thuần ta dùng được export và import như v thì file export phải được script vào file html dưới dạng module nhưng trong React config hết r nên k cần.



# Lazy loading 
Code splitting: Vào web thì browser tải từng file html css js về. Với React thì bundle lại thành bundle.js mới gửi tới trình duyệt. Nếu dự án lớn sẽ khiến file bundle to ra mà mỗi lần vào tải cả cục rất lâu. Code splitting là kỹ thuật tách ứng dụng 2 phần: chỉ load phần bundle cần thiết để khởi động, các phần khác sẽ load sau khi ứng dụng chạy.
1) Dynamic import: import là 1 promise, khi nào dùng mới tải về. Vd khi render thực sự 1 component ra mới load file bundle chứa component về.
Bth React optimize mọi module thành các file bundle.js, nhưng khi dùng dynamic import, các phần đó sẽ được React tách riêng ra k cho vào file bundle chung. Hđ với cả CSR SSR
Browser tự tối ưu n lần dynamic import sẽ chỉ tải 1 lần file js đó. Nếu vừa import bth, vừa dynamic import thì nó import bth xong sẽ k import lại gì nữa.
2) Lazy loading: y hệt, dùng để load cả 1 file component trong React.
=> Code spliting chỉ hiệu quả nếu split được các file lớn nên lazy loading được dùng nhiều. Còn dynamic import ít dùng hơn, VD khi cần import cả 1 thư viện lớn chẳng hạn.

Nơi nào cần dùng thì import bằng React.lazy -> Hiển thị component như bth nhưng bao ngoài bằng React.Suspense



# Dùng responsive
VD cần ẩn 1 nút bấm nếu là mobile, màn hình to thì hiển thị bth => có thể dùng css thuần cho display none thẻ đó or dùng code JSX check if else có render ra hay không

-> Dùng @media hoặc cách riêng của thư viện UI
-> Dùng lib react-device-detect 
-> Tự tạo 1 hook useDevice trả ra các biến phục vụ lấy kích thước màn hình hiện tại => best practice



# CSS Reset cho 1 dự án React bth
-> Các thuộc tính chung:
*{
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}
html{
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  font-smooth: always;
  height: 100%;
  width: 100%;
  overflow-y: scroll;
}
body{
  height: 100%;
  width: 100%;
}
:root{
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
    sans-serif;
  // => Font-family default của OS, nếu có 1 font dùng global chắc chắn tồn tại thì viết thêm vào đầu là được.
  text-rendering: optimizeLegibility;
}
#root{
  width: 100%;
  height: 100%;
  -webkit-touch-callout: none;
}

-> Các thuộc tính khác, đôi khi buộc phải set vì các thư viện nó thay đổi làm nó hỏng:
img{
  user-select: none;
  -webkit-user-drag: none;
}
a{
  text-decoration: none;
}
button{
  text-transform: none;
  cursor: pointer;
}
button:disabled{
  cursor: not-allowed;
}
Thẻ canvas cũng cản bôi đen và drag giống img
body dùng color-scheme light hay dark tùy
set thêm transition cho :root là (transition: all 0.5s linear;) vì lúc nào ta cũng muốn có 1 chút transition khi chuyển động

-> Có thể custom để quá màn hình thì k có thanh scroll nhưng vẫn có chức năng scroll. Nếu ta cần trong những website ngắn thì user nên scroll thay vì dịch đến vị trí luôn:
body {
  -ms-overflow-style: none;
  scrollbar-width: none;
}
body::-webkit-scrollbar {
  display: none;
}

-> Nếu muốn chiều dài page chuẩn màn hình hiện tại và hiển thị header và footer đúng. Set thẻ content chính với: minHeight="calc(100vh - chiều cao header - chiều cao footer)"
-> Dùng lib sanitize.css > normalize.css



# Dùng web worker
Dùng với lib @shopify/react-web-worker
Vd: sort 500000 phần tử bằng bubble sort trong react sẽ làm ui block. Mở tab performance của browser sẽ thấy ui bị block vài giây, nếu chạy nó trên 1 worker riêng, thời gian vẫn thế nhưng main thread sẽ k bị block. 
Web worker tận dụng chip đa nhân trên máy client luôn. K nên lạm dụng mà thêm khoảng 2-3 workers là ok => Nên dùng khi xử lý ảnh, canvas drawing, export CSV or excel file lớn

Tab performance monitor browser có CPU usage. Khi dùng web worker sẽ thấy CPU usage giảm mạnh



# React 18 Feature
Cho phép render undefined, bỏ các older browser, cải thiện bộ nhớ

-> Dùng createRoot là hàm enable concurrent feature của React18, nếu k dùng thì ứng dụng sẽ làm vc y như React17. Tương tự hàm hydrateRoot thay thế cho hydrate dùng cho SSR

-> Automatic Batching: 
VD state của 1 component đổi 2 lần thì render lại 2 lần, với React18 tối ưu hơn, gom 2 cái thay đổi lại và render theo cái cuối thôi. 
VD: setTimeout(() => {
  setSize((oldSize) => oldSize + 1); setOpen((oldOpen) => !oldOpen);
  // React will only re-render once at the end (that is batching)
}, 1000);
=> Đề phòng người dùng k muốn batching, nó sinh ra hàm flushSync để xem có update DOM hay k
function handleSubmit() {
  flushSync(() => { setSize((oldSize) => oldSize + 1); }); // React has updated the DOM by now
  flushSync(() => { setOpen((oldOpen) => !oldOpen); }); // React has updated the DOM by now
}



# Dùng React portal
Giúp render UI nằm ngoài component tree. VD modal, tooltip. Các thư viện toàn dùng ReactPortal cho các tính năng đó.
-> react-reverse-portal giúp tạo các cổng chuyển component tới đủ mọi nơi trong dự án trong component tree.



# Virtualize long list
Render list lớn trong React bị lag. K nên load tất cả, chỉ nên load và render phần nhìn thấy được.
- Phân trang
- Dùng react-window or react-virtualized chỉ show phần DOM visible. Kết hợp scroll down to load more



# Lazy loading image
3 vđ: loading lazy, placeholder khi loading và error, custom hiệu ứng khi hiện ảnh. 
Browser mặc định load ảnh nặng từ trên xuống từ từ, khi custom hiệu ứng sẽ làm nó đẹp hơn, còn khoảng trắng lúc chưa load xong phải chịu thôi, dùng placeholder mà che lại.

-> requestIdleCallback: hàm JS giúp thực hiện điều gì khi event loop k có task.
react-idle-timer*: lib giúp dùng requestIdleCallback trong React. Có thể load ảnh nặng, tải data nặng chưa cần dùng ngay nếu rảnh.

-> react-progressive-graceful-image*: loading lazy, placeholder, custom hiệu ứng
react-lazy-load-image-component: thêm loading='lazy' cho tag image và custom hiệu ứng khi hiện ảnh. 



# Tối ưu SEO React
-> Dùng React Helmet update thẻ metadata ở từng router, viết các thẻ metadata có giá trị mặc định ở mọi route trong index.html. 
Crawler exec code JS có thể thấy metadata đổi được set bởi React Helmet. 
Vd share web cho messager thì nó fetch lấy title và ảnh trong html chứ k exec JS nên sẽ giống nhau ở mọi route.
Thay vì dùng helmet, có thể update head tag thông qua global var document ok

-> Thêm descriptive text với mọi thẻ nếu có thể. Dùng cấu trúc url ngắn và descriptive
Nên dùng CDN để cung css, js, font chữ để giảm thời gian tải
Hạn chế lỗi để nội dung ẩn sau form login, kể cả chưa login cũng phải thấy gì đó. 

-> File robots.txt: xác định phần nào nên và k nên thu thập dữ liệu, nằm cùng cấp thư mục gốc của dữ liệu => thường để default
Googlebot k tìm thấy robots.txt vẫn thu thập dữ liệu bth. robots.txt có thể cản các crawler thu thập thông tin trang nhưng k cản được crawler của các công cụ tìm kiếm.

-> Giải pháp khác
1) Prerendering
Ta có thể dùng proxy kiểu nginx để check:
$http_user_agent ~* "googlebot|bingbot|yandex|baiduspider|twitterbot|facebookexternalhit|rogerbot|linkedinbot|embedly|quora link preview|showyoubot|outbrain|pinterest\/0\.|pinterestbot|slackbot|vkShare|W3C_Validator|whatsapp"
or
map $http_user_agent $limit_bots {
     default 0;
     ~*(google|bing|yandex|msnbot) 1;
     ~*(AltaVista|Googlebot|Slurp|BlackWidow|Bot|ChinaClaw|Custo|DISCo|Download|Demon|eCatch|EirGrabber|EmailSiphon|EmailWolf|SuperHTTP|Surfbot|WebWhacker) 1;
     ~*(Express|WebPictures|ExtractorPro|EyeNetIE|FlashGet|GetRight|GetWeb!|Go!Zilla|Go-Ahead-Got-It|GrabNet|Grafula|HMView|Go!Zilla|Go-Ahead-Got-It) 1;
     ~*(rafula|HMView|HTTrack|Stripper|Sucker|Indy|InterGET|Ninja|JetCar|Spider|larbin|LeechFTP|Downloader|tool|Navroad|NearSite|NetAnts|tAkeOut|WWWOFFLE) 1;
     ~*(GrabNet|NetSpider|Vampire|NetZIP|Octopus|Offline|PageGrabber|Foto|pavuk|pcBrowser|RealDownload|ReGet|SiteSnagger|SmartDownload|SuperBot|WebSpider) 1;
     ~*(Teleport|VoidEYE|Collector|WebAuto|WebCopier|WebFetch|WebGo|WebLeacher|WebReaper|WebSauger|eXtractor|Quester|WebStripper|WebZIP|Wget|Widow|Zeus) 1;
     ~*(Twengabot|htmlparser|libwww|Python|perl|urllib|scan|Curl|email|PycURL|Pyth|PyQ|WebCollector|WebCopy|webcraw) 1;
 } 
location / {
  if ($limit_bots = 1) {
    return 301 $scheme://domain.com$request_uri;
  }
}
=> Tức nếu request đến từ client bth thì show web react. Nếu đến từ bot crawler thì ta redirect đến 1 cache server trả ra data SSR tối ưu SEO => ít dùng
Prerendering có nhiều kiểu như sử dụng các dịch vụ SaaS, or thư viện Prerender.io, Prerender.cloud, SEO.js, BromBone

2) Dùng isomorphic với React
Isomorphic là dùng kiểu component render bởi cả server và client. Đó là kiểu server render component, gửi cho client hydrate lại. Đó là kiểu bth mà React có hàm hydrate
VD: React Redux Universal, AfterJS, Goldpage là các framework hỗ trợ, thế thà dùng mẹ nextjs gatsby.



# Dùng webpack
refer tới "Projects / Setup / setup react thủ công với webpack"
Có các package giúp cấu hình lại webpack như dotenv-webpack

-> npm run eject => Lệnh 1 chiều, làm cho bundler không còn tự động hóa mọi vấn đề nữa mà sẽ bung toàn bộ config để những dev có thể config lại tuỳ ý. K dùng nếu k rành webpack.

-> Lỗi: npm run build dự án react ra file index.html nhưng khi vào chỉ có 1 trang trắng. NN vì webpack config bản production thì build vào path "/" tức absolute tìm trong application chứ kp trong application/build. 
=> Fix bằng cách thêm vào package json "homepage":"." để chỉ định tải các file static của dự án với url là relative trong thư mục hiện tại là application/build
VD: custom "homepage": "./test", thì nhét thư mục static vào folder test cùng cấp là lại chạy được



# Dùng lib MUI v5
Tạo Google's Material Design, là 1 hình thức của Flat Design (thiết kế phẳng). Chỉ dựa vào thay đổi màu mà mang tới cảm giác 3D như có hiệu ứng nổi lên trên giao diện.

-> Packages đi kèm: notistack, react-material-ui-carousel
@mui/x-date-pickers và date-fns => tạo input date picker

-> Custom override với provider
const theme = createTheme();
theme.typography.h3 = {
  fontSize: '1.2rem',
  '@media (min-width:600px)': {
    fontSize: '1.5rem',
  },
  [theme.breakpoints.up('md')]: {
    fontSize: '2.4rem',
  },
}; => Custom thẻ h3 dùng typography mới dùng 1.2 rem và nhỏ hơn 600px sẽ dùng 1.5rem và lớn hơn md dùng 2.4rem

Có thể custom nhiều type khác của Typography:
typography: {
  subtitle1: {
    fontSize: 12,
  },
  body1: {
    fontWeight: 500,
  },
  button: {
    fontStyle: 'italic',
  },
} => Custom được mọi loại variant

-> Dùng styled
VD truyền props vào styled: 
const CustomClass = styled(Box, {
  shouldForwardProp: (prop) => prop !== "fontWeight" && prop !== "myProp",
})(({theme, myProp, fontWeight}) => ({
  ".background": {
    fontWeight,
  }
}));
và dùng: <CustomClass fontWeight="lighter" myProp>...</CustomClass> 

-> Customize thẻ có sẵn với css selector
VD customize TextField:
".test": {
  "& div.MuiFormControl-root": {
    "& div.MuiOutlinedInput-root": {
      "& fieldset": {
        borderColor: "red"
      }
    }
  }
}
Mẹo: khi cần lấy màu dùng color: "background.primary.main" mà éo cần useTheme => chỉ được khi dùng sx

-> Dùng css selector trong styled
".A": {
  "&:hover":{}
} => hover vào A thì thẻ A hiện ra cái gì
".A": {
  "&:hover .B": {}
} => hover vào A thì class B mang css gì
".A": {
  "& .B": {
    "&:hover": {}
  }
} => B là con của A thì hover vào sẽ mang css gì
".A": {
  "& $B": {}
} => thẻ có id là B và là con mọi cấp của A mang css gì
".A": {
  "& th:last-child, & td:last-child": {
  }
} => 1 list th td là con cuối cùng của thẻ có class A sẽ có css gì
".A": {
  "&:before": {} => before selector của A có css gì
  "&:hover": {
    "&:before": {} => hover vào A thì before selector của A sẽ có css gì
  },
  "&:hover img": {}, => hover vào A thì img trong nó mang css gì
} 
-> Customize lại 1 thẻ đặt thành tên khác:
const MainLayoutContainer = styled(Box)((theme) => ({
  backgroundColor: theme.theme.palette.background.body.main,
})); 

-> Dùng TextField: Dùng textfield select hơn là dùng component Select. Thay vì dùng input type number, nên dùng type text và tự check
Xử lý invalid input: có thể dùng formik or xử lý như html, css thuần là thêm pattern:"[a-z]{1,50}" và className:"input" và input:invalid:{<css>}
VD check if e.target.value = Number(e.target.value) để tránh ký tự lạ



# Dùng react-router-dom v6
Đổi router url nhưng vẫn là SPA. Có thể làm thủ công với window.history của JS thuần
Switch của v5 check route từ trên xuống đúng là dừng luôn, Routes v6 sẽ luôn chọn path đúng nhất nên k cần qt thứ tự nữa

-> Có thể tạo: nested route, default route, index route, dynamic route. Vd route not found:
<Routes>
  <Route path='/' element={<Dashboard />} />
  <Route path='*' element={<NotFound />} />
</Routes>

-> useNavigate: sẽ k hoạt động nếu component chứa nó chưa render xong
VD: navigate('/home', {replace: true}); => Dùng replace sẽ k lưu lại vào lịch sử trình duyệt, k thể back lại page trước.

-> Listen sự thay đổi của url: có thể dùng lib "history" createBrowserHistory để lấy ra 1 object có khả năng listen
Có thể dùng url làm global store lưu data, tạo 1 hook get, set, listen thay đổi
Config url page với createBrowserRouter hoặc useRoutes

-> VD <NavLink/> với isActive trong class style:
className={({ isActive }) => (isActive ? "navLink activeLink" : "navLink")}
style={{ isActive } => ({ color: isActive ? '#fff' : '' })}



# Dùng redux
Redux là flux đơn giản dựa trên kiến trúc ELM. Flux chính là cách dùng dispatcher, actions, controller, stores để bắt actions và xử lý. 
=> Redux thuần nên dùng với class component cũ, giờ nên dùng react-redux và redux-toolkit dùng cho functional component.

Luồng: thực hiện hành động trên view -> tạo action -> dispatcher dispatch action tới stores -> stores có middeware và reducer, middleware có thể dispatch actions mới hay báo lỗi nếu cần, reducer xử lý actions và cho state đầu ra là copy -> state lưu vào store và trả ra cho view provider -> mapStateToProps chuyển state thành props của component

-> Dùng redux-logger log actions và state trên store

-> Custom hook useAsync
Hook nhận 1 hàm, trả ra object có pending, error, data. Gọi hàm call chia 3 TH, khi đang gọi thì pending true, khi gọi xong thì có data, nếu có lỗi thì lấy error. 
=> useAsync thay thế được redux thunk. Còn redux saga cung nhiều hàm rất mạnh khác như takeEvery, takeLeading, takeLastest.
Hook useAsync, redux saga, redux thunk chỉ cần dùng nếu redux cần fetch API => Nên dùng React query cho async global store, redux cho sync global store k cần fetch.

-> Redux saga
Side effect là các hành động setTimeout, call api, đọc dữ liệu ổ cứng, tốn thời gian phải chờ mà ta k định lượng được. Redux saga giúp xử lý side effect trong redux.
Luồng: view -> dispatch actions -> middleware -> reducer -> state mới -> quay về view
                                      |          /^
                                      API -> done 
Dispatcher dispatch action sẽ thực hiện đồng thời, 1 phần đưa action vào reducers xử lý loading và show ra, 1 phần được saga ở middleware xử lý call api lâu hơn. Saga xử lý xong thì gửi tự dispatch 1 action đến reducers xử lý kết quả, update thành công hay thất bại. 
Action có thể được dispatch nhiều lần liên tiếp: takeLastest, call, put, all, takeEvery, delay, put, take, select, putResolve, race, fork, spawn

-> redux-toolkit: có sẵn nanoid sinh số random
Cách chuẩn nhất là dùng createSlice với createAsyncThunk (unwrap và rejectWithValue), extraReducer, createDraftSelector

--> Dùng createSlice:
Reducers thường được chia từng module riêng. VD redux thuần: const context = 'module1'; const 'ACTION_01' = `${context}_ACTION_01`; => Nhìn tên action là biết module nào
redux-toolkit xử lý điều này với createSlice. Nó tạo ra 1 slice ngắn gọn chứa luôn reducer và action. VD trong 1 module counter:
const counterSlice = createSlice({
  name: 'counter',
  reducers: {
    increment: state => state.count += 1,
    decrement: state => state.count -= 1
  }
}); export const { increment, decrement } = counterSlice.actions; export default counterSlice.reducer;
=> Sinh ra 2 action có types là counter/increment và counter/decrement và @@INIT mặc định. Nhóm reducer và action lại trong 1 object và ta export ra.
=> Mỗi module của ứng dụng nên là 1 slice riêng. Nếu reducer muốn bắt action khác module thì phải dùng đến extraReducers

---> Dùng createReducer hay extraReducers bên trong createSlice có 2 cú pháp: 
1) { [<action> / <action>.type / <action>.toString()]: (state, action) => ({ <đổi state> }) }
2) C1 là basic, nếu dùng thêm tính năng thì: (builder) => builder.addCase(<action>, (state, action) => ({ <đổi state> }))
Dùng addMatcher khi nhiều action type chung 1 xử lý. VD:
const isErrorAction = (action) => action.type.endsWith('FAIL');
const reducer = createReducer(initState, (builder) => {
  builder
    .addMatcher(isErrorAction, (state, action) => { state.errors = action.payload.errors; state.loading = false; })
    .addDefaultCase((state, action) => {})
})

--> const store = configureStore({reducer: rootReducer, middleware: (getDefaultMiddleware) => getDefaultMiddleware({serializableCheck: false}).concat(customMiddleware)})

--> useSelector của react-redux: lấy data từ redux và tiền xử lý. Dùng kèm ?. mọi lúc vì fetch chưa xong sẽ k có data.
createSelector giống lib "reselect" tối ưu hơn vì check tham số cũ khác tham số mới về giá trị thì mới chạy lại hàm
createDraftSafeSelector tương tự nhưng đảm bảo dùng immutable trong selector an toàn mà k đổi state redux và k cần copy data. Nó bắt sự thay đổi trực tiếp trong qúa trình. VD trong reducer dùng createSelector không đổi gì, dùng createDraftSafeSelector thì sẽ đổi luôn => luôn dùng thay createSelector

--> VD dùng redux-toolkit:
TH1: 
 slice: export const {<hàm>} = slice.actions;
 component: import { <hàm> } from "...slice"; -> dp(<hàm>)
TH2:
 slice: export const selectSlice = (state) => state.slice;
 component: const <att> = useSelector((state) => selectSlice(state).<att>);
TH3: 
 slice: tạo selectSlice như TH2 -> export const selectAtt = createDraftSafeSelector(state => selectSlice(state).<att>, (att) => { <xử lý các att.data> return {..} })
 component: let {data1, data2} = useSelector((state) => selectAtt(state));
TH4: tương tự TH3 nhưng xử lý từ nhiều thuộc tính của state
 slice: export const selectAtt = createDraftSafeSelecto(selectSlice, (slice) => { <xử lý mọi thuộc tính của slice.data> return {}});
TH5: các hàm fetch dữ liệu
 slice: export const fetchData = createAsyncThunk("<tên>", async(data, thunkAPI) => { await <gọi hàm bất đồng bộ>; return res; }) -> trong extraReducers xử lý [fetchData.fulfilled/pending/rejected](state,action) {state.data = action.payload.data;}
 component: import fetchData from "..";
=> TH5 có thể kết hợp Axios và Promise.all([thunkAPI.dispatch(function1(A)), thunkAPI.dispatch(function2(B))]);
