# Redux
Redux là flux đơn giản dựa trên kiến trúc ELM, chính là cách dùng dispatcher, actions, controller, stores để bắt actions và xử lý
Luồng: thực hiện action trên view -> dispatcher dispatch action tới stores -> stores có middeware và reducer, middleware dispatch actions mới hoặc báo lỗi nếu cần, reducer xử lý actions và cho state đầu ra -> state lưu vào store là gán = vì state là immutable và return cho view provider -> mapStateToProps chuyển state đó thành props cho component dùng.

-> Lib react-redux dùng thủ công => old rồi, có thể thay thế bằng react-query nếu chỉ lưu async state, kết hợp lưu url params và react context cho sync state.
Lib react-logger làm log middleware => old rồi, có thể tự tạo middleware log
Lib redux-thunk hỗ trợ bước call api => old rồi, có thể tự tạo hook useAsync nhận 1 hàm call api trả ra 1 object có pending, error, data, call thay cho redux-thunk.



# Dùng redux-saga
Giống redux-thunk hỗ trợ bước call api nhưng cho xử lý side effect phúc tạp.
Luồng: view -> dispatch actions -> middleware -> reducer -> state mới -> quay về view
                                      |          /^
                                      API -> done
Dispatcher dispatch action sẽ được xử lý đồng thời, 1 phần đưa action vào reducers xử lý show loading, 1 phần được saga ở middleware xử lý call api lâu hơn. Saga xử lý xong thì dispatch tiếp 1 action đến reducers xử lý kết quả thành công hay thất bại.
Saga kiểm soát dispatch action: takeLastest, takeLeading, takeEvery, call, put, all, delay, put, take, select, putResolve, race, fork, spawn

VD dùng redux saga dự án lớn:
Ở từng file xử lý từng module, dùng yield takeLatest/takeEvery
index.ts import hết r gom lại yield all([fork(<hàm import từng file>), fork(...)]), có thể gọi yield cancelled(); tuỳ ý
store.ts import index.ts sagas làm middleware của stores là xong
loading là state ở component ban đàu là true, onSuccess và onFailed truyền vào dispatch khi gọi từng actions set lại loading là false là ok



# Dùng redux-toolkit 
Có rtk query giúp lưu async state như react-query.

-> Dùng createSlice:
Trong redux thuần thì reducers chia từng module riêng với: const context = 'module1'; const 'ACTION_01' = `${context}_ACTION_01`; => Nhìn tên action là biết module nào
redux-toolkit xử lý điều này với createSlice, slice chứa reducer và action của 1 module. VD trong 1 module counter:
const counterSlice = createSlice({
  name: 'counter',
  reducers: {
    increment: state => state.count += 1,
    decrement: state => state.count -= 1
  }
}); 
export const { increment, decrement } = counterSlice.actions; 
export default counterSlice.reducer;
Sinh ra 2 action có types là counter/increment và counter/decrement và @@INIT mặc định. Export ra action và reducer.
Mỗi module của ứng dụng nên là 1 slice riêng. Có extraReducers nếu reduce muốn bắt action của module khác.

--> VD dùng createReducer hay extraReducers bên trong createSlice: 
C1: { [<action> / <action>.type / <action>.toString()]: (state, action) => ({ <đổi state> }) }
C2: cung nhiều tính năng hơn: (builder) => builder.addCase(<action>, (state, action) => ({ <đổi state> }))
Có addMatcher khi nhiều action type chung 1 xử lý. VD:
const isErrorAction = (action) => action.type.endsWith('FAIL');
const reducer = createReducer(initState, (builder) => {
  builder
    .addMatcher(isErrorAction, (state, action) => { state.errors = action.payload.errors; state.loading = false; })
    .addDefaultCase((state, action) => {})
})

-> const store = configureStore({reducer: rootReducer, middleware: (getDefaultMiddleware) => getDefaultMiddleware({serializableCheck: false}).concat(customMiddleware)})


-> State của redux là immutable const vì redux sử dụng ss nông với reference để biết có thay đổi không mà render lại, mỗi lần sẽ gán 1 object mới.
redux-toolkit tích hợp sẵn immer giúp viết đổi state trực tiếp như bth, sau đó nó tự tạo ngầm 1 new object để gán, giúp dễ viết hơn.

useSelector lấy state trong component phải dùng kèm ?. mọi lúc vì fetch chưa xong sẽ k có data.
createSelector giúp tiền xử lý data trước khi trả về cho component. createSelector có sẵn của redux-toolkit ss giá trị, mạnh hơn createSelector của lib "reselect" ss reference.
createDraftSafeSelector luôn dùng thay thế createSelector vì createSelector bị lỗi khi dùng cú pháp của immer.

-> Còn có createAsyncThunk để call api, unwrap để lấy kết quả từ rejectWithValue. Có nanoid sinh số random.

-> VD dùng redux-toolkit:
TH1: 
 slice: export const {<hàm>} = slice.actions;
 component: import { <hàm> } from "...slice"; -> dp(<hàm>)
TH2:
 slice: export const selectSlice = (state) => state.slice;
 component: const <att> = useSelector((state) => selectSlice(state).<att>);
TH3: 
 slice: tạo selectSlice như TH2 -> export const selectAtt = createDraftSafeSelector(state => selectSlice(state).<att>, (att) => { <xử lý các att.data> return {..} })
 component: let {data1, data2} = useSelector((state) => selectAtt(state));
TH4: tương tự TH3 nhưng xử lý từ nhiều thuộc tính của state
 slice: export const selectAtt = createDraftSafeSelecto(selectSlice, (slice) => { <xử lý mọi thuộc tính của slice.data> return {}});
TH5: các hàm fetch dữ liệu
 slice: export const fetchData = createAsyncThunk("<tên>", async(data, thunkAPI) => { await <gọi hàm bất đồng bộ>; return res; }) -> trong extraReducers xử lý [fetchData.fulfilled/pending/rejected](state,action) {state.data = action.payload.data;}
 component: import fetchData from "..";
=> có thể kết hợp Promise.all([thunkAPI.dispatch(function1(A)), thunkAPI.dispatch(function2(B))]);


