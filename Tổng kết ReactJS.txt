# Basic
npx create-vite => thay thế hoàn toàn CRA deprecated

-> Compiler sẽ chuyển từ JSX syntax sang JS bằng babel. JSX "label for" đổi sang "label htmlFor" => Tổng hợp: https://reactjs.org/docs/dom-elements.html
React.isValidElement(<ele>)

-> Dùng list buộc phải có key unique, nếu k khi thay đổi phần tử sẽ bị sai. Nếu k đổi thì dùng index làm key cũng được.
VD: Điểm khác biệt là ta xoá đi ptử thứ 8 trong list thì ptử 9 sẽ mang key là 8, ptu 10 sẽ mang key là 9, dẫn đến in sai.

-> HOC (Higher order component): hàm nhận component làm wrapper cho ra 1 component khác => k dùng mà nên biến thành 1 hook

-> Automatic Batching React 18
VD: setTimeout(() => { 
  setSize((oldSize) => oldSize + 1); setOpen((oldOpen) => !oldOpen); // state đổi liên tiếp sẽ tối ưu gom lại và render 1 lần thôi
}, 1000);
=> Đề phòng người dùng k muốn batching, nó sinh ra hàm flushSync để xem có update DOM hay k
function handleSubmit() {
  flushSync(() => { setSize((oldSize) => oldSize + 1); }); // React has updated the DOM by now
  flushSync(() => { setOpen((oldOpen) => !oldOpen); }); // React has updated the DOM by now
}

-> Dùng React.Context + useContext:
Chú ý state trong context đổi sẽ kéo mọi component rerender. Có thể chia nhiều context khác nhau cho từng con.

-> Dùng biến môi trường: có thể chia file .env, .env.production, .env.staging cho từng loại môi trường khác nhau
Có sẵn như CRA (REACT_) hay Vite (VITE_), hoặc dùng cross-env, dotenv.
Cũng có thể custom với webpack bằng lib dotenv-webpack, VD đổi k dùng tên file là .env nữa



# Dùng react compiler:
Full docs: https://react.dev/learn/react-compiler
Nó k render lại con nếu cha đổi props klq tới con, mà k cần useMemo component con => bỏ hoàn toàn useCallback, useMemo, React.memo
Biến const khai báo trong component sẽ k tạo lại sau mỗi lần render trừ khi nó phụ thuộc bién khác và biến đó bị đổi, mà k cần useMemo.

npx react-compiler-healthcheck@latest => check dự án hiện tại có tương thích với react compiler không.

eslint-plugin-react-compiler => package giúp eslint báo lỗi nếu dùng thư viện or code k tương thích với compiler. Chỉ cần cài và thêm vào eslint config:
import reactCompiler from 'eslint-plugin-react-compiler'
export default [
  {
    plugins: {
      'react-compiler': reactCompiler,
    },
    rules: {
      'react-compiler/react-compiler': 'error',
    },
  },
]

Nếu dùng vite phải thêm babel-plugin-react-compiler@beta và thêm vào vite config:
plugins: [
  react({
    babel: {
      plugins: [
        ["babel-plugin-react-compiler", { compilationMode: "annotation" }]
      ]
    }
  })
]
K được dùng swc version của react trong vite mà phải dùng normal version.
--> { compilationMode: "annotation" } chỉ có tác dụng với các component sử dụng "use memo" bên trong, k có thì áp dụng mọi component

Trong nextjs, cài babel-plugin-react-compiler và thêm vào next config: 
experimental: {
  reactCompiler: true,
}



# Cách ref tới 1 thẻ
Nếu thẻ đó có sự kiện như onClick thì ta có thể lấy mọi thông tin của thẻ đó luôn. VD event.target.innerText
Dùng biến lưu thẻ thì có thể truy cập mọi thứ của thẻ thông qua biến
Đảm bảo hàm chạy sau khi render thì có thể dùng query selector để lấy thẻ

-> Dùng const ref = useRef(null); rồi cho vào attribute ref của thẻ => bỏ createRef, thay thế forwardRef
VD: khi thẻ cha có hàm đổi styles của con của thẻ con, truyền ref vào con để refer tới thẻ bên trong con được.

-> Dùng useImperativeHandle: component cha gọi 10 hàm của component con ở nhiều thẻ mà chỉ truyền 1 ref được. 
URL: https://courses.webdevsimplified.com/view/courses/react-hooks-simplified/



# Tích hợp thư viện => các thư viện 1-2 năm k update cũng nên bỏ 
-> Ant Design, Blueprint UI, Rebass, Fluent UI, Evergreen UI, Grommet, react-foundation, Primereact, Bulma, materialize-css@next, React Suite, Kendo react (component lạ), radix-ui khó dùng
Chakra UI, Bootstrap, mui* v7, Senmatic UI
cuicui: thư viện ui sẵn component chỉ cần copy paste, rất nhiều component lạ
Có nhiều hệ thống thiết kế đi kèm thư viện UI như IBM Carbon* hay Twilio Paste, nó chứa guidline và các component chỉ dẫn cách để tạo 1 hệ thống UI có design nhất quán

Lib component kèm animation rất mạnh:
https://ui.aceternity.com/components 
https://www.ui-layout.com/components
https://www.cult-ui.com/docs/components/
https://www.eldoraui.site/components
https://syntaxui.com/components
https://www.hover.dev/components/
https://animata.design/docs

Bit Cloud: Là lib UI của bit.dev, cài nó thì dùng được thập cẩm component của nhiều thư viện khác nhau, tái sử dụng và chia sẻ giữa các dự án.
Search component trên bitcloud, ấn từng mục của các thư viện UI khác nhau. Nhưng trước đó phải cài bit trong dự án, nó sẽ import dưới dạng file cả dự án component vào và ta có thể chỉnh sửa tùy ý. Sau khi lấy components về rồi copy vào src/components để dùng.
react-rainbow-component*: Lib UI component có sẵn nhiều component lạ, nên thường dùng kết hợp bit cloud để tối ưu sức mạnh

-> ReactAdmin*: Thư viện giúp tạo trang admin cho các ứng dụng React dễ dàng.
ra-data-json-server dùng riêng cho ReactAdmin cung vào data json

-> @replexica/react hỗ trợ i18n bằng AI
react-intl*: thư viện giúp format số và chữ theo i18n

-> clsx*: tạo string với điều kiện, thg dùng cho className.
prop-types*: giúp typecheking và gán default value cho props của 1 component, check props type lúc runtime giảm thiểu lỗi. 
Date-fns hoặc Luxon => thay thế react-moment, moment-timezone
lodash*: https://lodash.com/docs/4.17.15 thay thế underscore => Có thể import tree shaking đỡ nặng: npm i lodash.merge
npm i rimraf -> tạo command: "build:clean": "rimraf ./build", là xong

-> react-scan => best lib giúp phát hiện vấn đề về performance, debug rerender luôn. Thay thế @welldone-software/why-did-you-render
Có browser extension, npm package. CDN: <script crossOrigin="anonymous" src="//unpkg.com/react-scan/dist/auto.global.js"></script>

-> react-cssfx-loading*. Bản html thuần: https://cssfx.netlify.app/
https://loading.io/* => icon loading customize thoải mái, export ra gif hay svg đều được
react-spinners*: thư viện component loading
react-content-loader: thư viện tạo skeleton svg nhẹ

-> @tinymce/tinymce-react*: thư viện giúp tạo TinyMCE text editor cực mạnh cho các kiểu input text như gg docs
react-hot-toast*
react-modal 
react-player*: custom play video
react-slick và slick-carousel: tạo carousel slider
react-trend: vẽ đường line
react-avatar-edit*: cắt ảnh làm avatar
react-paginate: tạo component phân trang
react-perfect-scrollbar: thư viện tạo thanh scrollbar, nó cung thêm tính năng khác như bắt sự kiện scroll đến vị trí trục y nào
react-text-transition
react-color*: color picker
react-datepicker: date picker
react-pdf
sweetalert: hộp thoại alert đẹp
react-qr-reader: quay camera QR
@pqina/flip*: tạo Flip Clock chuẩn
cmdk: hiển thị menu dạng có thể search
React Email cung components cho việc gửi email
@xyflow/react*(bản mới chuẩn của reactflow): thư viện rất mạnh để vẽ interactive graphs and node-based editors, tạo ra như kiểu draw.io ấy

-> react-select*: tạo đủ loại component input
react-text-mask*: custom input hiển thị

-> react-dnd*: thư viện drag drop của React cực mạnh, mỗi tội dùng redux phiên bản cũ nên xung đột
react-grid-layout: tạo grid draggable items

-> recharts*: Vẽ đồ thị kiểu học thuật.
highcharts-react-official highcharts*: tạo graph đẹp, responsive, loading
Victory thư viện vẽ biểu đồ cho data. Tremor cũng thế nhưng đẹp hơn. React Diagrams cho user vẽ biểu đồ có thể drag customize như draw io
D3 thư viện chuyên data visualization đủ loại phức tạp

-> Refine giúp cho việc xây ứng dụng react CRUD dễ dàng hơn. Nó cung copmonents, state management, hook.

-> Icon lib: react-icons*
https://ionic.io/ionicons => đơn giản mà đẹp
--> Lib cho icon svg tuỳ ý chỉnh sửa màu sắc, kích thước, stroke width
https://tablericons.com/category/Arrows => đủ loại định dạng
https://lucide.dev/icons/archive => nhiều icon lạ
https://icon-sets.iconify.design/ => có cả icon hình như cờ các nước cũng có
https://www.streamlinehq.com/icons => nhiều icon dị
https://iconoir.com/ => nhiều hình khối lạ
https://www.orioniconlibrary.com/all-icons => nhiều icon dị 
--> Or dùng đồng bộ 1 loại icon như 1 theme:
https://icons.getbootstrap.com/ => nên dùng nếu dùng bootstraps
https://heroicons.com/ 
https://feathericons.com/ 
https://boxicons.com/
https://www.uicons.com/icons-round?weight=medium&fill=outline&round-plans=free
https://iconmonstr.com/page/80/ => monochrome

-> styled-components*, @emotion/styled => style css trong js
linaria*: tạo component từ việc style lại tag html, nó extract code ra css files khi build làm kích thước lớn hơn. Còn styled-components thì k nhưng tăng JS bundle size. 

-> Clerk* => tool mạnh nhất để tạo dialog authentication. Nó hỗ trợ sẵn đủ loại login, thậm chí là login bằng tiktok hay discord, metamask, 2FA,... components UI sẵn luôn
-> Okta: lib authentication nên dùng với React thuần vì tương thích với react-router-dom
Setup: Login Okta -> Application -> Tạo 1 ứng dụng với OpenID Connect và SPA -> Sign-in và sign-out URI là đường dẫn của ứng dụng khi redirect, set port -> Allow everyone in your organization to access -> nó cung ClientID xác định app và Okta domain (dev-xxxxxxxx.okta.com). Tạo 1 server check access token từ FE qua Okta API với OAuth 2.0
Tạo dự án mẫu với okta-cli: tải okta cli -> okta login có org url là https://dev-xxxxxxx.okta.com, id là client id của app -> "okta create react"
ISSUER ID là https://dev-xxxxxxx.okta.com



# Pattern tuỳ biến style component
Khi dùng các component có sẵn từ nhiều nơi or các thư viện UI, nó thường cung API ở 1 mức độ nhất định thôi. 
=> Ta có thể ép style theo ý ta bằng CSS Selector, viết 1 thẻ bao ngoài và mang 1 class rồi cứ dùng css selector để style cho các con bên trong tùy ý. 



# React animation
-> Các kiểu tạo animation trong react: 
Animation css cơ bản: transition, @starting-style, dialog, details-content, interpolate-size allow-keywords, allow-discrete, :hover
Animation css keyframe
Lib có sẵn component animation hoặc tạo animation dễ hơn: MUI, @pqina/flip, react-text-transition, framer-motion, react-spring.
Nâng cao hơn nữa thì có threeJS là thư viện animation 3D cho react 

Kết hợp sự kiện JS: onMouseLeave onMouseOver thì đổi biến or setInterval useEffect đổi biến, r thuộc tính css gán theo biến
VD Tạo số chạy khi số liệu thay đổi hoặc component hiện ra lần đầu => ref tới "Projects Leaderboard HighChart / AnimatedNumber". 
Cơ chế: số là 1 biến state được đổi giá trị nhanh liên tục để rerender

Kết hợp dùng JS sửa css như html thuần với useLayoutEffect + useRef + requestAnimationFrame
useLayoutEffect(() => {
  const content = contentRef.current;
  if (isVisible) {
    content.style.maxHeight = content.scrollHeight + "px";
    content.style.opacity = "1";
  } else {
    requestAnimationFrame(() => {
      content.style.maxHeight = "0";
      content.style.opacity = "0";
    });
  }
}, [isVisible]);
=> useTransition chỉ khi xử lý logic nặng bằng js thôi, vd search nhanh lag. Còn đổi JS liên quan đến animation nên dùng requestAnimationFrame, nó đảm bảo frame sau sẽ gom đổi tất cả. setInterval setTimeout vẫn thực hiện tiép khi tab browser bị ẩn or k focus, nhưng requestAnimationFrame sẽ dừng lại giúp tiết kiệm tài nguyên

*** Để thẻ luôn hiện ở đó, isOpen=true thì gán thêm class để hiện ra kèm transition là được => best practice phổ biến nhất, thư viện chỉ giúp code như v gọn hơn thôi.
Nếu ta làm kiểu thẻ bth k tồn tại, khi mở mới mount vào DOM thì cần chú ý nó có thể break layout hiện có. VD gap hay grid flex bị sai. Dialog thì k tính vì dùng portal rồi.

-> Animation library: 
animate.css*: best animation css lib
react-spring*: tạo custom animation dưới dạng react hook. URL: https://www.joshwcomeau.com/react/boop
framer-motion*: animation được cho cả svg path
react-burger-menu: tạo animation cho thanh menu dọc thg khi màn hình nhỏ
@use-gesture: animation mạnh dựa vào tương tác của người dùng.
*** reactuseanimations-: lib giúp tạo microInteraction, là animation các thứ nhỏ nhặt khi hover và click, càng đơn giản càng đẹp
https://cursify.vercel.app/components => thư viện animate cursor đỉnh

--> Animation với scroll: 
react-awesome-reveal: reveal animation
react-animated-cursor => thư viện tạo animate cursor mỗi khi rê chuột đi đâu
react-parallax-mouse => thư viện hiệu ứng parallax bằng cách di chuyển chuột



# Thao tác với form
Nên gom mọi trường vào 1 biến useState object với setState({ ...state, [e.target.name]: e.target.value }); cho gọn.
***Khi dùng form, hãy luôn đặt thuộc tính autofocus vào ô đầu tiên mà người dùng cần nhập.

return false trong hàm xử lý sự kiện sẽ ngăn chặn chuyển trang, hoặc dùng e.preventDefault() tương tự.
Nó có thể áp dụng trong form hoặc bất cứ component nào gây chuyển trang. Vd thẻ a có href có thể xử lý điều này trong onClick của nó

Để submit form thông qua phím enter, nên giữ onSubmit của form và button có type submit là được.
Cách khác là custom khi form được focus thì bắt sự kiện onKeyDown bấm phím Enter.

-> react-hook-form*: lib tương tự formik. Nó còn có tool generate code luôn.

-> Lib formik*: điều đb là nó tự xử lý tối ưu khi có thay đổi chứ k render lại cả form. 
C1: Dùng component có sẵn Formik, FastField, Form, ErrorMessage => Cách này vẫn mang các điểm lợi của formik như render độc lập nhưng ít dùng.
C2: Cách dùng hook useFormik. 
Khởi tạo initialValues, validate, onSubmit. 
Hàm validate được gọi mỗi khi data của formik được update, return biến errors, biến này có thể truy xuất với formik.errors làm error helper text. Còn có formik.touched để truy cập xem trường nào đã từng được thao tác lần đầu chưa. VD: Để làm kiểu ấn vào trường a r ấn ra ngoài, bth nó sẽ chạy vào validate và set errors cho cả 2 trường a và b vì chưa có gì, nhưng ta chỉ muốn error trường đã tương tác thôi thì check formik.touched để đảm bảo 1 input chỉ báo lỗi 1 trường nếu đã tương tác và giá trị bị sai.
Có thể truy xuất giá trị bất cứ đâu với formik.values, còn formik.isValid trả ra true nếu hàm validate return ra object error rỗng, thực tế giá trị này rất hay ở chỗ nó formik.isValid ban đầu vào nó luôn trả ra true nếu ta chưa set gì cả, từ đó lợi dụng để ban đầu vào thì button submit enabled, khi ấn vào mới hiện ra các trường required cần dùng
Để update có hàm formik.setFieldValue("<field>", <value>) hoặc trong onChange có thể dùng formik.handleChange nhận vào biến e là input, cũng nên bắt cả onBlur={formik.handleBlur}. Mọi hàm khi gọi từ formik như change với blur đều chạy vào validate kiểm tra lỗi hết. setFieldValues hay handleChange k dùng async await vì sẽ bị lag khi nhập.
handleChange sẽ update bất đồng bộ nên ở phía dưới ta sẽ k thể sử dụng ngay formik.values mà chỉ có thể thao tác với e.target.value. Nên kết hợp debounce.
Submit form với formik.submitForm(e) và reset form với formik.resetForm()



//!!!!!!!!
# React hook
1 react hook bắt đầu bằng use, chỉ dùng hook ở top level, k dùng trong câu đk, hàm con, loop, nếu ta muốn dùng điều kiện thì phải nhét logic đó vào trong hook. 
Các state gán từ hook là immutable, k tạo lại mỗi khi rerender, biến const thì có tạo lại mỗi khi rerender.

-> Dùng useState: Có thể tách mỗi biến 1 useState hoặc gộp trong 1 object useState
setState(state + 1) tương đương setState(state => state + 1) nhưng cách truyền hàm đúng hơn vì state trong hàm luôn mang giá trị mới nhất ở future. Có lúc biến state truyền vào nó không phải giá trị mới nhất mà bị giữ lại như khi "Tạo đồng hồ đếm ngược".

-> Dùng useEffect: luôn chạy ít nhất 1 lần ở lần đầu tiên khi chưa có data gì cả nên cần phải check data chưa có gì thì bỏ qua, nó chạy async k block UI
Component khi chạy từ trên xuống, gặp useEffect sẽ lưu lại chờ return DOM cập nhập xong sẽ thực hiện. Nếu lại thay đổi state sẽ render lại tiếp.
Dùng return là 1 function. Khi 1 hàm useEffect được gọi, nó sẽ gọi vào return của useEffect trước đó rồi mới thực hiện useEffect mới, cũng gọi khi unmount.
Bản chất các loại hook có dependencies, nó lưu trong cache cho đến khi dependencies thay đổi thì xóa khỏi cache và thêm cái mới vào cache tiếp thôi.
Bên trong lại gọi hàm, hàm đó thường lưu vào useCallback 

Gọi setState trong useEffect xong thì bên dưới nó vẫn mang giá trị cũ. Sau khi render lại và chạy đến useState đó thì giá trị mới được gán.
Trong hàm useEffect ta mặc định setState là vẫn như giá trị cũ, nhưng bên ngoài nó sẽ render lại liên tục để hiển thị với giá trị mới. VD: Ban đầu loading là false rồi ta setLoading(true) trong useEffect thì hàm trong useEffect vẫn thực hiện tiếp với loading là false nhưng bên ngoài được render lại ngay với giá trị loading là true nhé.

VD: Component A chứa component B, cả 2 cùng useEffect dependencies đến biến x, nếu biến x đổi thì useEffect của cha sẽ thực hiện trước r đến dần các useEffect của con.
Nếu component A useEffect mà thực hiện chuyển trang khác nên component con k hiện ra nữa thì k chạy useEffect của con nữa. 
Nhiều thư viện npm tạo ra kp để dùng cho React mà HTML JS thuần, nhưng vẫn ép dùng trong React được 1 số TH với useEffect như ThreeJS

-> useLayoutEffect: giống useEffect nhưng thực hiện trc useEffect ngay sau khi render lên DOM (hình như ngay trước mới đúng). Nó k thực hiện async như useEffect.
Nên dùng useLayoutEffect khi cần thao tác với DOM mới cập nhập, thay đổi style trên DOM, nếu dùng useEffect sẽ bị giật do async song song với render.

-> useReducer: thực chất giống useState, ta dùng khi component cần quản lý state 1 cách rõ ràng hơn. Dispatch action -> reducer thực hiện đổi state.
Có thể dùng kết hợp với ReactContext tạo ra kiểu gần giống với redux. Component gọi useContext sẽ gọi cả useReducer và truyền cả [state, dispatch] và provider

-> useMemo: Hàm nên dùng useCallback, còn các thứ khác dùng useMemo dù useMemo thay thế useCallback được. Thực ra chỉ dùng lưu biến, component, hàm khi quá lớn or phức tạp.
Tương tự, const Con = React.memo(props => { return <>; }, x); chỉ khi props hay x đổi mới chạy lại hàm render lại Con => Thg dùng khi Cha có Con phức tạp mà k muốn Con rerender
=> useMemo có thể thay thế memo

-> useId sinh số Id. Trong redux toolkit cũng có nanoid sinh id ngẫu nhiên. VD 1 component có trường id mà render nhiều nơi, dùng useId cho nó sẽ đảm bảo duy nhất.
useSyncExternalStore read và subscribe vào external data source => VD ta subscribe vào localStorage được
useInsertionEffect* được gọi đồng bộ với mục đích thêm style cho DOM trước khi nó đọc layout với useLayoutEffect. Nó k access vào ref và k update state được => nên dùng khi cần sửa style DOM bằng JS code

-> URL: https://courses.webdevsimplified.com/view/courses/react-hooks-simplified/
useDebugValue; useEffectEvent** fix dependency error của useEffect; useFormStatus**;
use** k cần dùng nếu dùng react-query, gọi hàm lien tục khi chạy qua nên cần nhét hàm vào useMemo: https://www.youtube.com/watch?v=oMvW3A_IRsY

Case lỗi: function (url) {
  function onConnected(url) { console.log(url); }
  useEffect(() => onConnected(url), [url]);
} => nếu k truyền url vào onConnected, nó sẽ luôn dùng url mới nhất. useEffect chạy async k kiểm soát được. VD gọi hàm trong useEffect 2 lần thật nhanh bằng cách đổi url, sẽ có lúc onConnected chạy lần 1 với data của lần 2 là sai nên phải truyền. Tức url đổi ngay giữa lúc trigger useEffect và bên trong onConnected được gọi.

-> useTransition:
Hàm startTransition sẽ có ưu tiên thực hiện thấp hơn để k ảnh hưởng performance và nếu có 1 lệnh tương tự thì câu lệnh cũ sẽ bị dừng luôn và ưu tiên chạy câu lệnh mới. Nó tự chỉnh đảm bảo k bị lag => Dùng khi 1 hàm nặng phụ thuộc vào 1 giá trị. Chạy nhiều lệnh như nhau sẽ được gom thành 1, nhưng k có đk thời gian cụ thể như useDebounce.
Khi code cần xác định phần task nào gây lag cho browser đưa vào startTransition. VD fetch API thực tế k gây lag cho browser thì k cần. VD search 1 chữ và thực hiện filter trên 1000 phần tử, hành động filter sẽ cho vào startTransition, kp hành động đổi text, cũng kp hành động set data, mà cả hành động filter và setdata cần cho vào.

useDeferredValue: tương tự nhưng delay việc update giá trị cho 1 biến vào 1 biến khác. Vd ta gõ input thay đổi biến a và dùng biến a để search list 1000 phần tử. Rõ ràng gõ nhanh sẽ gây lag vì task tuần tự. Khi đó ta dùng useDeferredValue để biến a vẫn update realtime nhưng biến aDeferred cho vào hàm search sẽ update delay 1 tí tránh lag. 
Việc aDeferred update như nào phụ thuộc vào mức độ bận của main thread, nếu rất bận thì nó càng skip intermediate value nhiều hơn. Tương tự nó k dùng cho callapi mà dùng do lag vì update tuần tự. Chứ call api k lag nhưng ta cần giảm thiểu số lần call tới mức tối thiểu thì dùng debounce tốt hơn.

=> 2 ví dụ đó là 2 usecase tối ưu nhất. useTransition dùng khi cần chạy 1 hàm nặng ảnh hưởng tới performance. useDeferredValue dùng khi chạy 1 hàm nặng phụ thuộc vào 1 giá trị, nhưng giá trị đó có thể thay đổi liên tục nên cần defer chứ k thực hiện lại liên tục hàm nặng.

-> use(Promise): TH1 là dùng với 1 promise trong 1 component, sẽ có thể dùng nó trong conditional được. Wrap với ErrorBoundary và Suspense để hiện fallback, component dùng use(Promise) sẽ hiện fallback nếu promise chưa thực hiện xong, k cần dùng await cho nó.
Th2 là dùng với use(ReactContext) thì như useContext nhưng dùng được trong câu điều kiện

-> useOptimistic thường dùng khi biết khá chắc lệnh call sẽ success, fail tự undo => ít dùng mà thường dùng useDebounce hơn, nên implement failed tự undo cho useDebounce
VD: nếu người dùng update xong API chưa thành công đã tắt page => Có thể cản lại với window.addEventListener("beforeunload"); URL: https://www.youtube.com/watch?v=VBlSe8tvg4U

--> Pb: useOptimistic thì người dùng thấy update tức thì, kết quả API ta thường biết trước và cho nó rơi vào TH đa số, nếu sai thì undo.
Còn useDebounce hành động của người dùng cũng tức thì, nhưng data load ra ta kb trước là gì mà chỉ gom nhiều request làm 1 thôi.
=> Kết hợp cả 2 được mà nhỉ, data update tức thì nhưng delay lại, khi call api xong nếu fail thì revert



# Custom hook
Custom hook là 1 function có mục đích nhận đầu vào và cho đầu ra tự động biến đối theo đầu vào. Nó chỉ là gom logic trong 1 FC vào 1 hàm để tái sử dụng thôi
Mỗi lần function chạy đến custom hook sẽ thực hiện lại mọi thứ bên trong. Cần đảm bảo các biến bên trong cũng là hook để không khởi tạo lại mỗi lần chạy
Custom hook dùng như 1 component bình thường nhưng trả ra giá trị or hàm, chứ không trả ra component. Có thể return useCallback, useMemo để không chạy lại nếu cần.

useMousePosition
-> URL: https://courses.webdevsimplified.com/view/courses/react-hooks-simplified/
useToggle, useTimeout, useUpdateEffect, useArray, usePrevious, useStateWithHistory, useStorage, useFetch, useScript, useDeepCompareEffect, useEventListener, useOnScreen, useGeolocation, useStateWithValidation, useSize, useEffectOnce, useDarkMode, useCookie, useTranslation, useOnlineStatus, useRenderCount, useDebugInformation, useHover, useLongPress
Lấy được vị trí địa lý, thêm script js CDN được

-> Thư viện @mantine/hooks cung sẵn hàng loạt custom hook. Các hook mạnh là:
useMediaQuery và useClickOutside không thể thiếu với code frontend 
useIntersection check xem 1 component có visible toàn bộ trên màn hình không
useScrollLock khóa và mở khóa thanh scrollbar
useForm cung mọi thứ cho việc tạo form, bao gồm cả validate
-> aHooks
-> usehooks-ts*



# Request API
Nên nhớ luôn có try catch + async await

-> Setup proxy prefix: nếu chỉ connect 1 server, có thể viết trong package.json FE trường proxy là base url server. Mọi request API ở FE sẽ dùng base url đó
VD bth ta dùng: axios.get('http://localhost:4000/api/new') thì bh chỉ cần axios.get('/api/new') nếu dùng "proxy": "http://localhost:4000" trong package.json
Có thể dùng trong hàm axios.create để set baseURL.

-> Dùng axios: điểm thích nhất là .get thì params là undefined sẽ tự động k cho vào param, tự động xử lý array

--> Dùng withCredentials với 1 request: axios.get(BASE_URL + '/todos', { withCredentials: true }); Dùng với mọi request thì có thể là axios.defaults.withCredentials = true. 
Nó chỉ định yêu cầu HTTP từ Axios sẽ gửi kèms các credentials như cookies, sessions. VD nhiều lúc lỗi k set được cookies buộc phải dùng. Server phải có cors, nếu k sẽ lỗi.

--> Dùng interceptor giúp chặn trước khi gọi và sau khi nhận kết quả. VD
Khi gửi token đi có thể dùng axios.interceptors.request.use() và gán config.headers['X-Token']=<token>
Khi nhận về dùng axios.interceptors.response() để lấy lỗi trả về là expired thì code luôn việc request lại accessToken cho người dùng



# Pattern loading fetch API
Component bao ngoài dùng useEffect fetch API với dependencies [] và Promise.all, bên trong fetch data cơ bản chung. 
Loading nên dùng cho cả page nếu fetch lần đầu nhiều data hoặc skeleton từng phần tử. Có các component tích hợp sẵn loading như highchart thì dùng của nó hơn.
State có thể lưu trong redux nếu dùng nhiều nơi hoặc lưu ngay trong useState của component dùng nó. Có INITIAL, FETCHING, SUCCESS, FAIL.

Dùng react-query thì mọi thứ perfect, xử lý loading đầy đủ, hiển thị giá trị hiện tại mặc định, khi nào fetch xong thì tự nhảy thành giá trị mới.

Khi người dùng update có data mới, ta có thể show ra bằng cách:
- Fetch lại data => nếu k bị chậm, nếu data thường xuyên thay đổi, nếu cần realtime cao
- Update data thủ công trong FE nếu thấy request thành công, thậm chí dùng useOptimistic luôn => dùng khi update data đơn giản

-> Update component A nhưng component B bị ảnh hưởng
Cần đảm bảo có thực sự cần update component B không vì nhiều số liệu thống kê kqtr k cần update realtime. Nếu cần update: 
- Ta vào page dùng data nào là fetch lại data đó luôn để đảm bảo realtime. Chỉ các data ít đổi, data lớn fetch lâu mới lưu vào store và chỉ fetch khi bị stale.
- Dùng react-query, ta có thể invalidate query dễ dàng
- Nếu case đơn giản thì ta gọi hàm fetch data của B ở cuối hàm update của A luôn, làm v sẽ khó mở rộng trong tương lai.
- Xây biến needToUpdate cho từng component lưu vào redux, update biến này thì khi cần refetch component nào, component check dependencies needToUpdate trong useEffect là xong => chẳng khác nào ta đang implement lại react-query invalidate cả. Chưa xét TH người dùng mở nhiều tab và cần fetch xuyên tab.



# Progressive web app (PWA) 
Là web có tính năng: cache offline để dùng các tính năng cơ bản mà k cần mạng, cài web như 1 app trên mobile, push notification trên mobile dù k chạy app => thay thế mobile app
Browsers hiện đại hỗ trợ service worker (khác web worker) giúp tạo ứng dụng PWA: https://create-react-app.dev/docs/making-a-progressive-web-app/
VD cài "npx create-react-app my-app --template cra-template-pwa", mở lên browser 1 lần r tắt mạng đi, refresh trang thấy web vẫn chạy bth, tab application có Cache Storage.
Tuỳ ý custom pwa cho routing, assets, revalidate, API mới của service worker trong react có thể tuỳ chỉnh mọi thứ.



# Other
-> Cách debug trong React
Mở tab components -> settings -> highlight updates => Tool này giúp tìm các components render thừa
1) Debug bằng browser: Gõ debugger vào code React hoặc search code browser và đặt breakpoint -> mở browser sẽ dừng lại chỗ đó
2) Debug trên VSC: Vào dự án react trên VSC -> Tab Debug -> Run and Debug -> Phải tạo file .vscode/launch.json, chú ý url và là url trang web VD http://localhost:3000, và webRoot là thư mục làm việc chứa index.js VD ${workspaceFolder}/src. 
URL: https://code.visualstudio.com/docs/editor/debugging#_launch-configurations

-> https://vasanthk.gitbooks.io/react-bits/content/ => Tutorial React

-> Pattern search filter: Cần search, filter và paginate data theo các trường, còn các component chỉnh sửa các trường này ở xa nhau. 
Mỗi action search, filter, phân trang gọi 1 API mới. FE dùng react query để tránh query lại, kiểm soát data stale => Luôn dùng
Lấy tất cả data lưu vào redux hoặc component cha. Còn phân trang, filter, search làm thủ công ở FE. VD fetch data từ SM buộc phải fetch mọi thứ 1 lần thì dùng

-> Pattern force reload lại component dù chỉ đổi biến phụ thuộc localStorage
VD component A chứa component B, B set giá trị cho localStorage, A refer đến giá trị trong localStorage. Component A sẽ k render lại nếu component B đổi giá trị localStorage. 
C1: Check localStorage mỗi 1s 
C2: Khi B update localStorage, gọi hàm cho A lấy lại localStorage

-> Tách component để state 1 comp đổi sẽ k rerender lại component k dùng state đó. VD 2 TH:
1) <Search> <Hiển thị> tách 2 component
2) <Search> -> Thêm <Hiển thị> ở cuối trong component <Search>
=> Dùng C1 thì mục đích là ta muốn chia ra các component con nhưng muốn dùng data của <Search> trong <Hiển thị> thì phải dùng biến search từ component cha truyền cho con k tốt, trừ khi dùng global state ở đây. Theo chuẩn tên OOP thì C1 tốt hơn vì <Hiển thị> kp 1 thành phần của search bar
=> Thực chất có thể lấy con từ cha được với useRef cũng hay mà k cần khai báo state ở cha vì state k thực sự là 1 phần của cha
VD: Ấn 1 button hiện ra dialog thì nên để button đó và dialog cùng là 1 component chứ k tách 2 file riêng

-> webpack-bundle-analyzer: tool show trực quan phần nào của ứng dụng chiếm nhiều dung lượng nhất
@welldone-software/why-did-you-render: check component nếu được rerender nhiều lần, dùng nó để check số lần rerender để fix tăng performance nếu code react chưa tốt
storybook: package giúp tách từng component, hiển thị dạng phân cấp giúp dễ theo dõi component
react-cosmos: thay thế storybook
react-styleguidist: Viết docs cho component -> dài éo dùng
https://github.com/kusti8/proton-native: Tool code React nhưng sinh ra ứng dụng desktop. Ứng dụng được compiled sang native platform code nên thực sự là native

-> Ngoài folder src dùng CommonJS require, files trong src dùng ES6 import. Tuỳ biến package Browsify có thể cấu hình FE dùng CommonJS, còn Babel giúp NodeJS dùng ES6 được.
Trong HTML thuần ta dùng được export và import như v thì file export phải được script vào file html dưới dạng module nhưng trong React config hết r nên k cần.

-> React19 hỗ trợ SSR dễ dàng hơn, giống như NextJS.

-> URL xây 1 hệ thống hỗ trợ hỏi đáp AI, dựa trên tập data từ SQL: https://www.freecodecamp.org/news/talk-to-databases-using-ai-build-a-sql-query-data-extractor/ 
Dùng GroqAI cho AI model train với data rồi tương tác qua CopilotKit, tự động xử lý NLP và mọi thứ chuyên cho chat.